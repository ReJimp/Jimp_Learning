# 计算机系统基础笔记

## chapter02 数据的机器级表示与处理

### 0x00 数值概念

- 机器级数据分类
  - 数值数据：无符号整数、带符号整数、浮点数（实数）
  - 非数值数据：逻辑数（包括位串）、西文字符和汉字
- 真值和机器数
  - 机器数：用0和1编码的计算机内部的0/1序列
  - 真值：带正负号的十进制数
- 数值表示三要素
  - 进位计数制
    - 10、2、8、16进制
  - 定、浮点表示
    - 定点整数、定点小数
    - 浮点数
  - 二进制编码
    - 原码、补码、反码、移码
- 定点数&浮点数
  - 小数点位置约定在固定位置的数称为定点数；小数点位置约定为可浮动的数称为浮点数
  - 定点小数用来表示浮点数的尾数部分，定点整数用来表示整数，分带符号整数和无符号整数

### 0x01 补码表示

- 补码(模运算)
  - 补码为n位，定义：[X]补=(2^n) + X，-2^(n-1) ≤ X ＜2^(n-1)，一个负数的补码等于模减该负数的绝对值
  - 加减法统一，克服了原码的缺点
  - 减法本质：对于某一确定的模，某数减去小于模的另一数，可以用该数加上另一数负数的补码来代替
  - 一个负数的补码等于将对应正数补码，各位取反、末位加一(简便计算方法：负数的绝对值从右往左数，第一个出现的1左边的位全部取反)，eg：[-7]补=[-0111]补=[1001]
  - 一个负数补码的真值等于数值各位取反，末位加一(数值部分从右往左数，第一个出现的1左边的位全部取反)
- 变形补码
  - 双符号，用于存放可能溢出的中间结果
  - 其他与补码相同

<img src="./img/2.png" style="zoom: 50%;" />

- 移码

  - 定义：将每一个数值加上一个偏置常数
  - 用来表示浮点数的阶码，避免对阶过程中出现负数大于正数的情况，如-1(111)  >  3(011)

- 机器中字的位排列顺序

  - 大端：0x12345678在内存中低地址到高地址的存储方式：12 34 56 78
  - 小端：0x12345678在内存中低地址到高地址的存储方式：78 56 34 12

- C语言中的整数

  - 若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数

    - 数据类型的表示范围

    |          关系表达式           |  类型  | 结果 |
    | :---------------------------: | :----: | :--: |
    |           0 = = 0U            | 无符号 |  1   |
    |            -1 < 0             | 有符号 |  1   |
    |            -1 < 0U            | 无符号 |  0   |
    | 2147483647 > -2147483647 - 1  | 有符号 |  1   |
    | 2147483647U > -2147483647 - 1 | 无符号 |  0   |
    | 2147483647 > (int) 2147483648 | 有符号 |  1   |
    |            -1 > -2            | 有符号 |  1   |
    |      (unsigned) -1 > -2       | 无符号 |  1   |

  - 编译器差别

    <img src="./img/3.png" style="zoom: 50%;" />

    - C90出现的问题：（1）-2147483648 > 2147483647 （2）-2147483648-1 = 2147483647

### 0x02 浮点数表示

- 浮点数表示

  <img src="./img/4.png" style="zoom: 67%;" />			

  - | S（0-1） | 阶码E（2-8） | 尾数M（9-31） |
    | :------: | :----------: | :-----------: |

    第0位数符S；第1～8位为8位移码表示阶码E（偏置常数为128）；第9～31位为24位二进制原码小数表示的尾数M。规格化尾数的小数点后第一位总是1，故规定第一位默认的“1”不明显表示出来。这样可用23个数位表示24位尾数；最大正数：0.11…1 x 2^

    (11…1)=(1-2^-24) x 2^127，最小负数：0.10…0 x 2^(00…0) = (1/2) x 2^(-128)

    ![](./img/5.png)

  - 规格化表示：规格化数的小数点前为1

  - IEEE 754 标准

    - | S(1 bit) | Exponent(8 bit) | Significand(23 bit) |
      | :------: | :-------------: | :-----------------: |

    - 阶码全0和全1表示特殊值，规格化阶码的范围为0000 0001 (-126) ~ 1111 1110 (127)

    - (SP)单精度的偏置常数为127，(DP)双精度的偏置常数为1023

    - SP: (-1)^S x (1 + Significand) x 2^(Exponent-127)； DP：(-1)^S x (1 + Significand) x 2^(Exponent-1023)

  - 特殊形式的浮点数

    - +0、-0：除了符号为1或0，阶码与尾数部分全为0                                                                                                                          +0: 0 00000000 00000000000000000000000，-0: 1 00000000 00000000000000000000000
    - +∞、-∞：符号为0或1，阶码部分全为1，尾数部分全为0，                                                                                                             +∞ : 0 11111111 00000000000000000000000，-∞: 1 11111111 00000000000000000000000
    - NaN(非数)(辅助调试程序)：阶码全为1，尾数部分不全为0

### 0x03 整数运算

- 加减运算

  - [A+B]补=A + B + 2^ n=A + 2^n + B + 2^n=[A]补+[B]补，[A-B]补=[A]补+[B]补

  - 标志计算：OF=Cn-1异或Cn（C代表进位），CF=Cout异或Cin

  - 无符号加溢出条件：CF=1，带符号加溢出条件：OF=1

  - 无符号减溢出条件：CF=1，带符号减溢出条件：OF=1

  - 减法比较大小规律：（1）无符号：CF=0时，大于；（2）OF=SF时，大于

  - 无符号数加溢出判断：

    ```c
    int uadd_ok(unsigned x, unsigned y)
    {
        unsigned ret = x + y;
        return ret >= x;
    }
    ```

  - 带符号数加溢出判断：

    ```c
    int tadd_ok(int x, int y)
    {
        int ret = x + y;
        if(x >= 0 && y >= 0 && ret < 0)
            return 0;
        else if(x < 0 && y < 0 && ret >= 0)
            return 0;
        else
            return 1;
    }
    ```

  - 带符号数减溢出判断：

    ```c
    int tsub_ok(int x, int y) 
    {
        if(!x && y == 0x80000000)
            return 0;
    	else
            return tadd_ok(x, -y); 
    }
    ```

- 乘除运算

  - 若x为浮点数，x^2>=0;若x为带符号整数， x^2不一定>=0

  - 带符号乘积结果正确的情况：高n+1位全0或1；无符号乘积结果正确的情况：高n位全0

  - 程序可以自行加判断

    ```c
    int mul(int x, int y)
    { 
        int z=x*y;
        if(!x || z / x == y)
            return z;
        else
            return 0;
    }
    ```

  - 溢出漏洞

    ```c
    int copy_array(int *array, int count) { 
        int i; 
        /* 在堆区申请一块内存 */
        int *myarray = (int *) malloc(count*sizeof(int)); 
        if (myarray == NULL) 
            return -1;
        for (i = 0; i < count; i++) 
            myarray[i] = array[i]; 
        return count; 
    } 
    ```

    malloc的参数为无符号类型，发生溢出后进行模运算，得到较小的值，申请到一个小内存，却可以向堆区写入大量数据

### 0x04 浮点数运算



## chapter03 程序的转换及机器级表示

